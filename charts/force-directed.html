<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        text {
            font: 10px sans-serif;
        }

        .background {
            fill: none;
            pointer-events: all;
        }

        #chart1 .node {
            stroke: #fff;
            stroke-width: 1.5px;
        }

        #chart1 .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
        }

        .chart-tooltip {
            height: auto;
            padding: 6px;
            position: absolute;
            width: auto;
            border-radius: 10px;
        }
    </style>
</head>

<body onload="chart1()">
    <p id="chart1" />
    <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="../design/js/fisheye.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js" integrity="sha512-WFN04846sdKMIP5LKNphMaWzU7YpMyCU245etK3g/2ARYbPK9Ub18eG+ljU96qKRCWh+quCY7yefSmlkQw1ANQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <script type="text/javascript">
        function chart1() {
            let data = JSON.parse(localStorage.getItem('refine'));

            var width = 960,
                height = 500;

            const colors = [
                "#857c85",
                "#d27d7d",
                "#c16548",
                "#b960a7",
                "#ddbd4d",
                "#705177",
            ];

            var color = d3.scale.category20().range(colors);

            var fisheye = d3.fisheye.circular().radius(120);

            var force = d3.layout
                .force()
                .charge(-240)
                .linkDistance(40)
                .size([width, height]);

            var svg = d3
                .select("#chart1")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            const zoomSvg = d3.behavior.zoom()
                        .on('zoom', function(event) {
                        // const transform = d3.zoomTransform(this)
                        console.log(d3.event.scale)
                        if(d3.event.scale > 5) return
                        d3.select('.graph')
                        .attr("transform", "translate(" + d3.event.translate + ") scale(" + d3.event.scale + ")");
                        })

            svg  = d3.select("svg")
                    .append("g")
                    .classed('graph', true)
                    // .attr("transform","scale(1.3)")
                    .call(zoomSvg)

            svg
                .append("rect")
                .attr("class", "background")
                .attr("width", width)
                .attr("height", height);


            const tooltip = d3
                .select("#chart1")
                .append("div")
                .attr("class", "chart-tooltip")
                .style("opacity", 0)
                .style("color", "#000");

            let groupData = _.chain(data.entities).groupBy("cluster").value();

            let mainData = {
                nodes: [],
                links: [],
            };

            let finalData = {
                nodes: [],
                links: [],
            };

            let sourceCounter = 0
            let targetCounter = 0
            let changedGroupValue = 0
            let oldKey = ''
            Object.keys(groupData).forEach(function(item, key) {
                    let groupList = groupData[item]

                    groupList.forEach(function(innerGroupItem, innerKey) {
                        finalData["nodes"].push({
                            "name": innerGroupItem.entity,
                            "group": innerGroupItem.cluster,
                            "size": innerGroupItem.size
                        });

                        if (oldKey !== '') {
                            finalData["links"].push({
                                source: changedGroupValue,
                                target: sourceCounter,
                                value: 1,
                            })
                            targetCounter = sourceCounter
                                // sourceCounter += 1
                            oldKey = ''
                        }

                        finalData["links"].push({
                            source: sourceCounter,
                            target: targetCounter,
                            value: 1,
                        })
                        sourceCounter += 1
                    })

                    // storing parent loop key
                    oldKey = key
                        // targetCounter = sourceCounter
                    changedGroupValue = targetCounter
                })
                // debugger
            console.log(finalData)
            finalData["links"].shift()
            data = finalData;

            var n = data.nodes.length;

            force.nodes(data.nodes).links(data.links);

            // Initialize the positions deterministically, for better results.
            data.nodes.forEach(function(d, i) {
                d.x = d.y = (width / n) * i;
                // Generate co-ordinate in arc
                let r = 20 * Math.sqrt(Math.random())
                let theta = Math.random() * 2 * Math.PI
                d.x = d.x + r * Math.cos(theta)
                d.y = d.y + r * Math.sin(theta)
            });


            // Run the layout a fixed number of times.
            // The ideal number of times scales with graph complexity.
            // Of course, don't run too longâ€”you'll hang the page!
            force.start();
            for (var i = n; i > 0; --i) force.tick();
            force.stop();

            // Center the nodes in the middle.
            var ox = 0,
                oy = 0;
            data.nodes.forEach(function(d) {
                (ox += d.x), (oy += d.y);
            });
            (ox = ox / n - width / 2), (oy = oy / n - height / 2);
            data.nodes.forEach(function(d) {
                (d.x -= ox), (d.y -= oy);
            });

            var link = svg
                .selectAll(".link")
                .data(data.links)
                .enter()
                .append("line")
                .attr("class", "link")
                .attr("x1", function(d) {
                    return d.source.x;
                })
                .attr("y1", function(d) {
                    return d.source.y;
                })
                .attr("x2", function(d) {
                    return d.target.x;
                })
                .attr("y2", function(d) {
                    return d.target.y;
                })
                .style("stroke-width", function(d) {
                    return Math.sqrt(d.value);
                });

            const outerCircle = svg
                .selectAll(".node")
                .data(data.nodes)
                .enter()
                .append("g");

            let getDynamicRadiusFromSize = (size) => {
                return 4.5 * (parseInt(-Math.log(size, 10)) / 4);
            };

            var node = outerCircle
                .append("circle")
                .attr("class", "node")
                .attr("cx", function(d) {
                    return d.x;
                })
                .attr("cy", function(d) {
                    return d.y;
                })
                // .attr("r", 4.5)
                .attr("r", function(d) {
                    // debugger
                    return 4.5 * (parseInt(-Math.log(d.size, 10)) / 4);
                }) // setting dynamic radius from size
                .style("fill", function(d) {
                    return color(d.group);
                })
                .on("mouseover", (d) => {
                    tooltip.transition().duration(200).style("opacity", 0.9);
                    tooltip
                        .html(d.name)
                        .style("left", `${d3.event.layerX + 20}px`)
                        .style("top", `${d3.event.layerY}px`)
                        .style('width', 'fit-content');
                    tooltip.style("background-color", color(d.group));
                })
                .on("mouseout", function(d) {
                    tooltip.transition().duration(200).style("opacity", 0);
                })
                .call(force.drag);

            var text = outerCircle
                .append("text")
                .attr("class", "text")
                .attr("y", function(d) {
                    return d.y - 10;
                })
                .attr("x", function(d) {
                    return d.x;
                })
                .text(function(d) {
                    return d.name;
                });

            svg.on("mousemove", function() {
                fisheye.focus(d3.mouse(this));

                node
                    .each(function(d) {
                        d.fisheye = fisheye(d);
                    })
                    .attr("cx", function(d) {
                        return d.fisheye.x;
                    })
                    .attr("cy", function(d) {
                        return d.fisheye.y;
                    })
                    .attr("r", function(d) {
                        return d.fisheye.z * 4.5 * (parseInt(-Math.log(d.size, 10)) / 4);
                    });

                link
                    .attr("x1", function(d) {
                        return d.source.fisheye.x;
                    })
                    .attr("y1", function(d) {
                        return d.source.fisheye.y;
                    })
                    .attr("x2", function(d) {
                        return d.target.fisheye.x;
                    })
                    .attr("y2", function(d) {
                        return d.target.fisheye.y;
                    });

                outerCircle
                    .select("text")
                    .attr("x", (d) => {
                        return d.fisheye.x;
                    })
                    .attr("y", function(d) {
                        return d.fisheye.y - 10;
                    });
            });
        };
    </script>
</body>

</html>